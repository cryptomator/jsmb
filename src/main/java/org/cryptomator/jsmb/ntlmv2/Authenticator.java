package org.cryptomator.jsmb.ntlmv2;

import org.cryptomator.jsmb.common.NTStatus;
import org.cryptomator.jsmb.util.Bytes;
import org.cryptomator.jsmb.util.Layouts;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;

/**
 * Performs the NTLM v2 Authentication
 * @see <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/5e550938-91d4-459f-b67d-75d70009e3f3">NTLM v2 Authentication</a>
 */
class Authenticator {

	public static AuthResponse ntlmV2Auth(NtlmChallengeMessage challengeMessage, NtlmAuthenticateMessage authenticateMessage, String user, String passwd, String userDom) throws AuthenticationFailedException {
		byte[] responseKeyNT = NTOWFv2(passwd, user, userDom);
		byte[] responseKeyLM = LMOWFv2(passwd, user, userDom);
		var serverChallenge = challengeMessage.serverChallenge();

		if (authenticateMessage.userNameLen() == 0
				&& authenticateMessage.ntChallengeResponseLen() == 0
				&& (authenticateMessage.lmChallengeResponseLen() == 0 || Arrays.equals(new byte[]{0x00}, authenticateMessage.lmChallengeResponse()))) {
			throw new AuthenticationFailedException(NTStatus.STATUS_LOGON_FAILURE, "Anonymouse authentication disabled");
		}

		var ntlmV2Response = authenticateMessage.ntlmV2Response();
		byte[] challengeFromClient = ntlmV2Response.challengeFromClient();
		var time = ntlmV2Response.timestamp();
		var expectedResponse = computeResponse(responseKeyNT, responseKeyLM, serverChallenge, challengeFromClient, time, ntlmV2Response.avPairsSegment().toArray(Layouts.BYTE));

		if (!Arrays.equals(expectedResponse.ntChallengeResponse(), authenticateMessage.ntChallengeResponse())) {
			// TODO: spec recommends retrying with NIL domain to maximize comnpatibility
			throw new AuthenticationFailedException(NTStatus.STATUS_LOGON_FAILURE, "Invalid challenge response");
		}

		return expectedResponse;
	}

	public static byte[] NTOWFv2(String passwd, String user, String userDom) {
		byte[] md4Hash = Crypto.md4(passwd.getBytes(StandardCharsets.UTF_16LE));
		return Crypto.hmacMd5(md4Hash, (user.toUpperCase() + userDom).getBytes(StandardCharsets.UTF_16LE));
	}

	public static byte[] LMOWFv2(String passwd, String user, String userDom) {
		return NTOWFv2(passwd, user, userDom);
	}

	/**
	 * Calculates the keys used in NTLM v2 authentication.
	 * @param responseKeyNT result of NTOWF() function
	 * @param responseKeyLM result of LMOWF() function
	 * @param serverChallenge The 8-byte challenge message generated by the server
	 * @param clientChallenge The 8-byte challenge message generated by the client
	 * @param time The 8-byte little-endian time in GMT
	 * @param avPairs The {@link NtlmV2Response#avPairsSegment()}, including the EOL AVPair
	 * @return The expected NT and LM challenge responses and the session base key
	 * @see <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/5e550938-91d4-459f-b67d-75d70009e3f3">NTLM v2 Authentication</a>
	 */
	private static AuthResponse computeResponse(byte[] responseKeyNT, byte[] responseKeyLM, byte[] serverChallenge, byte[] clientChallenge, byte[] time, byte[] avPairs) {
		byte[] responseVersion = new byte[]{1, 1}; // Responserversion, HiResponserversion
		byte[] temp = Bytes.concat(responseVersion, new byte[6], time, clientChallenge, new byte[4], avPairs); // omitting the last 4 zero bytes mentioned in the linked documentation, as avPairs include EOL already
		byte[] ntProofStr = Crypto.hmacMd5(responseKeyNT, Bytes.concat(serverChallenge, temp));
		byte[] ntChallengeResponse = Bytes.concat(ntProofStr, temp);
		byte[] lmChallengeResponse = Bytes.concat(Crypto.hmacMd5(responseKeyLM, Bytes.concat(serverChallenge, clientChallenge)), clientChallenge);
		byte[] sessionBaseKey = Crypto.hmacMd5(responseKeyNT, ntProofStr);
		return new AuthResponse(ntChallengeResponse, lmChallengeResponse, sessionBaseKey);
	}

	record AuthResponse(byte[] ntChallengeResponse, byte[] lmChallengeResponse, byte[] sessionBaseKey) {
	}
}